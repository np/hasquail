module TranslateQuail where

-- Haskell module generated by the BNF converter

import Prelude hiding (exp, id)
import Absquail
import qualified Types as T
{-
import ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x
-}

transIdent :: Ident -> String
transIdent x = case x of
  Ident str  -> str


transProgr :: Progr -> T.Program
transProgr x = case x of
  Program decs -> map transDec decs
 -- Program decs -> [transDec decs]


transDec :: Dec -> T.Decl
transDec x = case x of
  Decl mode typ id initializer  -> T.Decl (transMode mode) (transTyp typ) (transIdent id) (transInitializer initializer)
  Code stm -> T.Code (transStm stm)


transInitializer :: Initializer -> T.Initializer
transInitializer x = case x of
  NoInit  -> T.NoInit
  ExpInit exp  -> T.ExpInit (transExp exp)
  IntervalInit ranges  -> T.IntervalInit $ map transRange ranges

transRange :: Range -> T.Range T.Expr
transRange x = case x of
  Rng exp1 exp2  -> T.Range (transExp exp1) (transExp exp2)


transMode :: Mode -> T.Mode
transMode x = case x of
  Const  -> T.Const
  Observable  -> T.Observable
  Public  -> T.Public
  Secret  -> T.Secret
  Private  -> T.Private


transIndex :: Index -> T.Expr
transIndex x = case x of
  Idx exp  -> transExp exp


transStm :: Stm -> T.Stmt
transStm x = case x of
  SAssign id ixs exp  -> T.Assign (transIdent id, map transIndex ixs) (transExp exp)
  SIf exp stm1 stm2  -> T.If (transExp exp) (map transStm stm1) (map transStm stm2)
  SWhile exp stm -> T.While (transExp exp) (map transStm stm)
  SReturn  -> T.Return


transExp :: Exp -> T.Expr
transExp x = case x of
  EOpA exp1 op2 exp3  -> app2 op2 exp1 exp3
  EOpB exp1 op2 exp3  -> app2 op2 exp1 exp3
  EOpC exp1 op2 exp3  -> app2 op2 exp1 exp3
  EOpD exp1 op2 exp3  -> app2 op2 exp1 exp3
  EOpE exp1 op2 exp3  -> app2 op2 exp1 exp3
  EVar id ixs  -> T.Var (transIdent id) (map transIndex ixs)
  EInteger n  -> T.Lit n
 where app2 op2 e1 e2 = T.Op2 (transOp2 op2)
                              (transExp e1) (transExp e2)

transOp2 :: Op -> T.Op2
transOp2 x = case x of
  OPlus  -> T.Add
  OTimes  -> T.Mul
  OMinus  -> T.Sub
  OLt  -> T.Rel2 T.LT
  OLe  -> T.Rel2 T.LE
  OGt  -> T.Rel2 T.GT
  OGe  -> T.Rel2 T.GE
  OEq  -> T.Rel2 T.EQ
  ONe  -> T.Rel2 T.NE
  OAnd  -> T.And
  OOr   -> T.Or

transTyp :: Typ -> T.Type
transTyp x = case x of
  TInt n  -> T.TyInt (fromInteger n) -- no bound check
  TArray exp typ  -> T.TyArray (transExp exp) (transTyp typ)



